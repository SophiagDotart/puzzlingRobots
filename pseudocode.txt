Complete pseudocode puzzling robots:
# state: passive - listen if sth is received
# state: active - decide whether to update mode or even instructions and forward the result of said decision 
# state: root - has received instructions directly from user, converts and forwards it

# List of variables so far:
bool PASSIVE = 0
bool ACTIVE = 0
bool ROOT = 0

int t <- 0         // timestamp of the internal counter
int tN <- 0        // timestep of the neighbours counter; rcv in msg
int r <- 0         // r is the timestamp in which the instruction was received

int c <- 0          // traffic counter

int q <- 0          // number of neighbours
int p <- 0          // randomly selected neighbour number

# Functions required from user
getSignal()
sendMsg(PUSHPULL, p, id, t, r, map)

# Functions
decodeMsg(){                    // decode the incoming msg
  getMsg()
  return idN, tN, rN, mapN      //map is returned but not decoded yet
}    
decodeIntruct(){                // decode the incoming instrct
  return ;
}   
createMap()
updateMap()

msgRcv(PUSHPULL, q, t){
  decodeMsg()
  PASSIVE = 0                   // wake up, there is work!
  ACTIVE = 1                    // now, work
  c++                           // increase traffic counter
  if (t < tN){                  //if own timestamp is older than received one
    t <- tN                       //overwrite timestamp
    updateMap()                   //update own map according to the new one !self added
  }
  else if (t > tN) {            //if own timestamp is newer than received one
    send(REPLY, value) to q       //send own map so the neighbour can update its own map
  }
  else{  	                      //in any other case
    compareMap()                  //directly check each ones map
  }
}    

instrctRcv(){                   // when a new instruction from the user comes in, change the proceedings accordingly
  decodeInstrc()
  createMap()
  updateMap()
  r = t                         // set the new timestamp for the root
  createMsg()
  PASSIVE = 0                   // wake up, there is work
  ROOT = 1                      // congrats! You started a new instruction ------------------is needed? or does r suffice?
  ACTIVE = 1                    // now, work
}

# tb implemented
# -- if nothing happens, termnine yourself -> bercome PASSIVE?
# maybe better if neighbours are treated as objects? Is there a proper way to do it in C variations or python
# add successcibility algorithm here to collition avoidance -> what happens when a busy neighbour is selected

# Events
on timeout                      // timeout here refers to the end of listening period
  q<- random(p)                    //select random neighbour 
  sendMsg(PUSHPull, p, id, t, r, map) to q    //send to selected neighbour
  set timeout delta 

on getSignal                    // to categorize the incoming signal into either a msg or an instrct
  readMsg()
  if (mode == msg) {
    msgRcv()
  }
  else if (mode == instrc) {
    instrctRcv()
  }
  else {
    pass
  }


MAIN:
While (PASSIVE == 1 & ACTIVE == 0 & ROOT == 0) { //if nothing is heard yet, you get to chill
  listen()
}
While (ACTIVE = 1) {
  If (ROOTN & r < rN ) {
    r = rN  	                  //update roots timestamp
    updateMap()
    createMsg()
  }
  Else{
    If (t < tN ){
      updateMap()
      t = tN
    }
    Else {
      sendMsg()
    }
    delay()
    sendMsg()
  }
}









if r < rN:
  updateMap
  c= 0 % counter threshold trickle
  r = rN + 1 //update new root with timestamp
  createMsg
else:
  cmpTimestamps() etc.
